<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>
<body>
    <h3>자바스크립트의 오브젝트</h3>
    <ul>
        <li> - 자바스크립트의 객체를 정의하기 : 기호{} </li>
        <li> - 자바에서는 객체의 구성 요소 - 속성,메소드 - 미리 클래스로 정의 </li>
        <li> - 자바스크립트는 구성요소를 미리 정의하지 않는 프로토타입 기반 입니다. </li>
        <li> ☞ 구성요소인 속성과 메소드의 추가를 쉽게 할 수 있습니다. </li>
    </ul>
    <pre style="font-size: 1.2rem;font-family: inherit;">
        <script>
            // 객체리터럴을 const 변수 sana에 대입
            const sana = {name: '사나', age:23, address: '경기'}

            document.writeln('sana 이름=', sana.name)
            document.writeln('sana 나이=', sana.age)
            document.writeln('sana 지역=', sana.address)
            document.writeln('sana =', sana)
            console.log('sana =', sana)
            sana.height = 172;
            console.log('sana =', sana)
            

            //객체의 메소드는 함수 리터럴로 정의합니다.
            //새로운 속성이름은 hello, 그리고 값은 함수 ☞ hello 는 메소드가 됩니다.
            //화살표 함수는 익명 객체 형태입니다. 그래서 this를 사용 못합니다.
            sana.hello = function() {
                alert(`안녕하세요. 나는 ${this.name} 입니다.`)
            }
            sana.hello()
            sana.name = 'sanaaaaa'
            sana.hello()

            //구성요소가 없는 객체리터럴 선언
            const momo = {}
            momo.color = 'red'

            //배열값이 없는 빈 배열 선언
            const arr = []
            //배열값 형식이 달라도 저장할 수 있습니다.
            const arr1 = ['a',123]

            //객체의 구성요소가 다르지만 같은 배열에 저장할 수 있습니다.
            const objarr = [momo, sana]
            console.log(objarr)

        </script>
        <!-- 공공데이터 rest api 에서 받는 데이터 형식 중 하나가 자바스크립트 객체와 변환되는 
            json 문자열 입니다.(*****************)
            rest api 는 데이터를 전송받을 때 사용하는 하나의 규칙입니다.
            - 서버의 주소, 파라미터(요청값), method, 자원의 위치(url에 포함)를 요청하면
            - xml 또는 json 형식의 데이터를 응답해 줍니다.

            rest api 요청을 자바스크립트의 비동기 통신
        -->

    </pre>
    
</body>
</html>